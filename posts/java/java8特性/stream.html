<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/coldcurrent/favicon.png" />
    

    <title>
        
          HANCLOD的个人博客
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/coldcurrent/css/book.css">

    
<script src="/coldcurrent/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.0.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/coldcurrent/">
    <img src="/coldcurrent/favicon.png">
    <span>HANCLOD的个人博客</span>
  </a>
</div>
    <div class="book-menu">
  <ul>
<li><a href="/hexo-theme-book-demo">Home</a></li>
<li><a href="/hexo-theme-book-demo/changelog">Changelog</a></li>
</ul>
<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><ul>
<li><p><a href="/coldcurrent/posts/java/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html">正则表达式</a></p>
</li>
<li><p>java 8 特性</p>
</li>
<li><ul>
<li><a href="/coldcurrent/posts/java/java8%E7%89%B9%E6%80%A7/stream.html">stream 流</a></li>
</ul>
</li>
<li><ul>
<li><a href="/coldcurrent/posts/java/java8%E7%89%B9%E6%80%A7/optional.html">optional</a></li>
</ul>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><a href="/coldcurrent/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html">七大设计原则</a></li>
<li>创建型</li>
<li><ul>
<li><a href="/coldcurrent/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html">七大设计原则</a></li>
</ul>
</li>
<li><ul>
<li><a href="/coldcurrent/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html">七大设计原则</a></li>
</ul>
</li>
<li>构造型</li>
</ul>
<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><ul>
<li><a href="/coldcurrent/posts/angular/Angular%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.html">组件生命周期钩子</a></li>
<li><a href="/coldcurrent/posts/angular/Angular%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BA%A4%E4%BA%92.html">组件之间交互</a></li>
</ul>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul>
<li>DDL</li>
<li>DML</li>
<li>SQL高级特性</li>
<li><ul>
<li><a href="/coldcurrent/posts/SQL/SQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E2%80%94%E7%B4%A2%E5%BC%95.html">SQL高级特性—索引</a></li>
</ul>
</li>
</ul>

</div>


<script src="/coldcurrent/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
<p>特点：</p>
<p>​    1 . 不是数据结构，不会保存数据。</p>
<p>​    2. 不会修改原来的数据源，它会将操作后的数据保存到另外一个对象中。（保留意见：毕竟peek方法可以修改流中元素）</p>
<p>​    3. 惰性求值，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。</p>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><p><img src="../../../image/java/java%E5%9F%BA%E7%A1%80/stream01.png" alt="img"></p>
<p>  无状态：指元素的处理不受之前元素的影响；</p>
<p>  有状态：指该操作只有拿到所有元素之后才能继续下去。</p>
<p>  非短路操作：指必须处理所有元素才能得到最终结果；</p>
<p>  短路操作：指遇到某些符合条件的元素就可以得到最终结果，如 A || B，只要A为true，则无需判断B的结果。</p>
<h2 id="3-具体用法"><a href="#3-具体用法" class="headerlink" title="3 具体用法"></a>3 具体用法</h2><h3 id="3-1-流的常用创建方法"><a href="#3-1-流的常用创建方法" class="headerlink" title="3.1 流的常用创建方法"></a>3.1 流的常用创建方法</h3><ul>
<li>使用Collection下的 stream() 和 parallelStream() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用Arrays 中的 stream() 方法，将数组转成流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(nums);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Stream中的静态方法：of()、iterate()、generate()</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">6</span>);</span><br><span class="line">stream2.forEach(System.out::println); <span class="comment">// 0 2 4 6 8 10</span></span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">2</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 BufferedReader.lines() 方法，将每行内容转成流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;F:\\test_stream.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">Stream&lt;String&gt; lineStream = reader.lines();</span><br><span class="line">lineStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 Pattern.splitAsStream() 方法，将字符串分隔成流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stringStream = pattern.splitAsStream(<span class="string">&quot;a,b,c,d&quot;</span>);</span><br><span class="line">stringStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-流的中间操作"><a href="#3-2-流的中间操作" class="headerlink" title="3.2 流的中间操作"></a>3.2 流的中间操作</h3><h4 id="3-2-1-筛选与切片"><a href="#3-2-1-筛选与切片" class="headerlink" title="3.2.1 筛选与切片"></a>3.2.1 筛选与切片</h4><ul>
<li>filter：过滤流中的某些元素</li>
<li>limit(n)：获取n个元素</li>
<li>skip(n)：跳过n元素，配合limit(n)可实现分页</li>
<li>distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">14</span>);</span><br><span class="line"> </span><br><span class="line">Stream&lt;Integer&gt; newStream = stream.filter(s -&gt; s &gt; <span class="number">5</span>) <span class="comment">//6 6 7 9 8 10 12 14 14</span></span><br><span class="line">        .distinct() <span class="comment">//6 7 9 8 10 12 14</span></span><br><span class="line">        .skip(<span class="number">2</span>) <span class="comment">//9 8 10 12 14</span></span><br><span class="line">        .limit(<span class="number">2</span>); <span class="comment">//9 8</span></span><br><span class="line">newStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-映射"><a href="#3-2-2-映射" class="headerlink" title="3.2.2  映射"></a>3.2.2  映射</h4><ul>
<li><p>map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</p>
</li>
<li><p>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;1,2,3&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将每个元素转成一个新的且不带逗号的元素</span></span><br><span class="line">Stream&lt;String&gt; s1 = list.stream().map(s -&gt; s.replaceAll(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">s1.forEach(System.out::println); <span class="comment">// abc  123</span></span><br><span class="line"> </span><br><span class="line">Stream&lt;String&gt; s3 = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">    <span class="comment">//将每个元素转换成一个stream</span></span><br><span class="line">    String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">    <span class="keyword">return</span> s2;</span><br><span class="line">&#125;);</span><br><span class="line">s3.forEach(System.out::println); <span class="comment">// a b c 1 2 3</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-2-3-排序"><a href="#3-2-3-排序" class="headerlink" title="3.2.3 排序"></a>3.2.3 排序</h4><ul>
<li>sorted()：自然排序，流中元素需实现Comparable接口</li>
<li>sorted(Comparator com)：定制排序，自定义Comparator排序器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;ff&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line"><span class="comment">//String 类自身已实现Compareable接口</span></span><br><span class="line">list.stream().sorted().forEach(System.out::println);<span class="comment">// aa dd ff</span></span><br><span class="line"> </span><br><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">30</span>);</span><br><span class="line">Student s4 = <span class="keyword">new</span> Student(<span class="string">&quot;dd&quot;</span>, <span class="number">40</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2, s3, s4);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//自定义排序：先按姓名升序，姓名相同则按年龄升序</span></span><br><span class="line">studentList.stream().sorted(</span><br><span class="line">        (o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.getName().equals(o2.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-消费"><a href="#3-2-4-消费" class="headerlink" title="3.2.4 消费"></a>3.2.4 消费</h4><p>​     peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Student&gt; studentList = Arrays.asList(s1, s2);</span><br><span class="line"> </span><br><span class="line">studentList.stream()</span><br><span class="line">        .peek(o -&gt; o.setAge(<span class="number">100</span>))</span><br><span class="line">        .forEach(System.out::println);   </span><br><span class="line"> </span><br><span class="line"><span class="comment">//结果：</span></span><br><span class="line">Student&#123;name=<span class="string">&#x27;aa&#x27;</span>, age=<span class="number">100</span>&#125;</span><br><span class="line">Student&#123;name=<span class="string">&#x27;bb&#x27;</span>, age=<span class="number">100</span>&#125;            </span><br></pre></td></tr></table></figure>

<h3 id="3-3-流的终止操作"><a href="#3-3-流的终止操作" class="headerlink" title="3.3 流的终止操作"></a>3.3 流的终止操作</h3><h4 id="3-3-1-匹配、聚合操作"><a href="#3-3-1-匹配、聚合操作" class="headerlink" title="3.3.1 匹配、聚合操作"></a>3.3.1 匹配、聚合操作</h4><ul>
<li>allMatch：接收一个 Predicate 函数，当流中每个元素都符合该断言时才返回true，否则返回false</li>
<li>noneMatch：接收一个 Predicate 函数，当流中每个元素都不符合该断言时才返回true，否则返回false</li>
<li>anyMatch：接收一个 Predicate 函数，只要流中有一个元素满足该断言则返回true，否则返回false</li>
<li>findFirst：返回流中第一个元素</li>
<li>findAny：返回流中的任意元素</li>
<li>count：返回流中元素的总个数</li>
<li>max：返回流中元素最大值</li>
<li>min：返回流中元素最小值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">boolean</span> allMatch = list.stream().allMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">boolean</span> noneMatch = list.stream().noneMatch(e -&gt; e &gt; <span class="number">10</span>); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> anyMatch = list.stream().anyMatch(e -&gt; e &gt; <span class="number">4</span>);  <span class="comment">//true</span></span><br><span class="line"> </span><br><span class="line">Integer findFirst = list.stream().findFirst().get(); <span class="comment">//1</span></span><br><span class="line">Integer findAny = list.stream().findAny().get(); <span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> count = list.stream().count(); <span class="comment">//5</span></span><br><span class="line">Integer max = list.stream().max(Integer::compareTo).get(); <span class="comment">//5</span></span><br><span class="line">Integer min = list.stream().min(Integer::compareTo).get(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-组合"><a href="#3-3-2-组合" class="headerlink" title="3.3.2 组合"></a>3.3.2 组合</h4><p><code>reduce()</code> 方法的主要作用是把 Stream 中的元素组合起来，它有两种用法：</p>
<p> <code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></p>
<p>没有起始值，只有一个参数，就是运算规则，此时返回 Optional</p>
<p> <code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></p>
<p>有起始值，有运算规则，两个参数，此时返回的类型和起始值类型一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ReduceStreamDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer[] ints &#x3D; &#123;0, 1, 2, 3&#125;;</span><br><span class="line">        List&lt;Integer&gt; list &#x3D; Arrays.asList(ints);</span><br><span class="line"></span><br><span class="line">        Optional&lt;Integer&gt; optional &#x3D; list.stream().reduce((a, b) -&gt; a + b);</span><br><span class="line">        Optional&lt;Integer&gt; optional1 &#x3D; list.stream().reduce(Integer::sum);</span><br><span class="line">        System.out.println(optional.orElse(0));</span><br><span class="line">        System.out.println(optional1.orElse(0));</span><br><span class="line"></span><br><span class="line">        int reduce &#x3D; list.stream().reduce(6, (a, b) -&gt; a + b);</span><br><span class="line">        System.out.println(reduce);</span><br><span class="line">        int reduce1 &#x3D; list.stream().reduce(6, Integer::sum);</span><br><span class="line">        System.out.println(reduce1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运算规则可以是 Lambda 表达式（比如 <code>(a, b) -&gt; a + b</code>），也可以是类名::方法名（比如 <code>Integer::sum</code>）。程序运行的结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-收集操作"><a href="#3-3-3-收集操作" class="headerlink" title="3.3.3 收集操作"></a>3.3.3 收集操作</h4><p>​     collect：接收一个Collector实例，将流中元素收集成另外一个数据结构。</p>
<blockquote>
<p>Collector&lt;T, A, R&gt; 是一个接口，有以下5个抽象方法：<br>       Supplier<A> supplier()：创建一个结果容器A<br>       BiConsumer&lt;A, T&gt; accumulator()：消费型接口，第一个参数为容器A，第二个参数为流中元素T。<br>       BinaryOperator<A> combiner()：函数接口，该参数的作用跟上一个方法(reduce)中的combiner参数一样，将并行流中 各个子进程的运行结果(accumulator函数操作后的容器A)进行合并。<br>       Function&lt;A, R&gt; finisher()：函数式接口，参数为：容器A，返回类型为：collect方法最终想要的结果R。<br>       Set<Characteristics> characteristics()：返回一个不可变的Set集合，用来表明该Collector的特征。有以下三个特征：<br>         CONCURRENT：表示此收集器支持并发。（官方文档还有其他描述，暂时没去探索，故不作过多翻译）<br>         UNORDERED：表示该收集操作不会保留流中元素原有的顺序。<br>         IDENTITY_FINISH：表示finisher参数只是标识而已，可忽略。     </p>
</blockquote>
<p>（1） Collector 工具库：Collectors</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">&quot;aa&quot;</span>, <span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;bb&quot;</span>, <span class="number">20</span>,<span class="number">2</span>);</span><br><span class="line">Student s3 = <span class="keyword">new</span> Student(<span class="string">&quot;cc&quot;</span>, <span class="number">10</span>,<span class="number">3</span>);</span><br><span class="line">List&lt;Student&gt; list = Arrays.asList(s1, s2, s3);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//装成list</span></span><br><span class="line">List&lt;Integer&gt; ageList = list.stream().map(Student::getAge).collect(Collectors.toList()); <span class="comment">// [10, 20, 10]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//转成set</span></span><br><span class="line">Set&lt;Integer&gt; ageSet = list.stream().map(Student::getAge).collect(Collectors.toSet()); <span class="comment">// [20, 10]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//转成map,注:key不能相同，否则报错</span></span><br><span class="line">Map&lt;String, Integer&gt; studentMap = list.stream().collect(Collectors.toMap(Student::getName, Student::getAge)); <span class="comment">// &#123;cc=10, bb=20, aa=10&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//字符串分隔符连接</span></span><br><span class="line">String joinName = list.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>)); <span class="comment">// (aa,bb,cc)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//聚合操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.学生总数</span></span><br><span class="line">Long count = list.stream().collect(Collectors.counting()); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//2.最大年龄 (最小的minBy同理)</span></span><br><span class="line">Integer maxAge = list.stream().map(Student::getAge).collect(Collectors.maxBy(Integer::compare)).get(); <span class="comment">// 20</span></span><br><span class="line"><span class="comment">//3.所有人的年龄</span></span><br><span class="line">Integer sumAge = list.stream().collect(Collectors.summingInt(Student::getAge)); <span class="comment">// 40</span></span><br><span class="line"><span class="comment">//4.平均年龄</span></span><br><span class="line">Double averageAge = list.stream().collect(Collectors.averagingDouble(Student::getAge)); <span class="comment">// 13.333333333333334</span></span><br><span class="line"><span class="comment">// 带上以上所有方法</span></span><br><span class="line">DoubleSummaryStatistics statistics = list.stream().collect(Collectors.summarizingDouble(Student::getAge));</span><br><span class="line">System.out.println(<span class="string">&quot;count:&quot;</span> + statistics.getCount() + <span class="string">&quot;,max:&quot;</span> + statistics.getMax() + <span class="string">&quot;,sum:&quot;</span> + statistics.getSum() + <span class="string">&quot;,average:&quot;</span> + statistics.getAverage());</span><br><span class="line"> </span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; ageMap = list.stream().collect(Collectors.groupingBy(Student::getAge));</span><br><span class="line"><span class="comment">//多重分组,先根据类型分再根据年龄分</span></span><br><span class="line">Map&lt;Integer, Map&lt;Integer, List&lt;Student&gt;&gt;&gt; typeAgeMap = list.stream().collect(Collectors.groupingBy(Student::getType, Collectors.groupingBy(Student::getAge)));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//分区</span></span><br><span class="line"><span class="comment">//分成两部分，一部分大于10岁，一部分小于等于10岁</span></span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; partMap = list.stream().collect(Collectors.partitioningBy(v -&gt; v.getAge() &gt; <span class="number">10</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//规约</span></span><br><span class="line">Integer allAge = list.stream().map(Student::getAge).collect(Collectors.reducing(Integer::sum)).get(); <span class="comment">//40</span></span><br></pre></td></tr></table></figure>

<h3 id="参考目录"><a href="#参考目录" class="headerlink" title="参考目录"></a>参考目录</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qing_gee/article/details/105238960">https://blog.csdn.net/qing_gee/article/details/105238960</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/y_k_y/article/details/84633001">https://blog.csdn.net/y_k_y/article/details/84633001</a></li>
</ul>

</div>


  <div class="book-comments">
    




  </div>



<script src="/coldcurrent/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="H"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>HANLIUKUI</div>
      <div>2020-08-12</div>
    </div>
  </div>

  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/coldcurrent/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/coldcurrent/js/book.js"></script>
